<!-- node.js러는걸 통해서 js설치 안해도 서버 기능 구현 가능
>> 엄청 많이 써먹을거임


Module Counts란?:
	미리짜여진 코드 >> 처음부터 코드를짜지 않고 쇼핑하듯담음 > 이것이npm install뭐시기!!
	코딩은 직접짜기보다 긁어오는게 중요함


오류메세지를 그대로 구글에 치면 나오는경우가 많다.(물론 파일 이름같은거는 다 지워야 한다.)



npm이란?:
	모든 코드를 다 짜는게 아니니까 npm 으로 함 왠만한 모듈은 다 이미 개발이 되어 있음 ㅋㅋ 

	package.json은 현재 내가 어떤 모듈을 사용하고 있는지 대략적으로 나와있는거고
	package-lock.json은 위의 상세버젼임


웹프레임워크:
	프론트엔드에서 요청하고 백엔드에서 응답 이런 웹 프레임워크를 이용하는게 express의 역할임

npm uninstall:
	모듈 삭제 >> 피글렛같이 쓸데없는 모듈 삭제해버리기!

express 사용:
	app.post로 /주소에 들어온 사람에게 xx를 줌
	
app.listen이란?:
	포트에 대한이해가 필요함 프트는 선착장임 노트북에서도 usb포트 hdmi포트 따로 있음
	3000번도 있고 80번도 있고 등등  서버에 들어가는 입구가 여러개고 그 입구가 포트임!
	ip는 대표번호고 port는 내선번호라고 생각하면 댐!
	일반적으로 포트는 무엇을 쓸지 정해져 있음 번호마다 다른걸 줄수 있음!
	
          app.listen(port, () => {
	console.log("Example app listening on port ${port}")
)}
하면 지금 port 번째 포트를 듣고 있다 즉, 받아들일 준비가 되어 있다 이런뜻임 대충 ㅇㅋ? 콘솔.log부분은 그냥 출력하는거라서
기능적인 의미는 없음!


	[nodemon] app crashed - waiting for file changes before starting... << 이거 뭐노? node index.js하면 서버 실행되는데 
npm  start하면 저렇게 오류가 뜸 //메인서버에 figlet 변수지정을 했는데 내가 나중에 figlet을 uninstall 했기 때문임


app.get('/',()=>{})
여기서 get은 http메소드, '/'는 라우팅, ()=>{}는 콜백 함수임

http메소드란?:
	요청의 목적, 종류를 알리는 수단임 get과 post방식이 있음
	get: 주소창 남김
	post:주소창이 아니라 바디에 어떤 정보를 담아서 요청을 보내는 것이다.

라우팅:
	유튜브/체널/132124뭐시기뭐시기 >> 이런게 라우팅임

콜백함수:
	함수(끝내고 실행할 함수)  ()=>{} 첫번째꺼 다음에 두번째껄 하겠다~!!


res.send('hello world') 와 같은 콜백 함수 안에다가 <h1></h1>와 같은 html 태그도 넣을 수 있고 
<a href ="www.youtube.com")과 같은 링크도 넣을수 있다.

axios 는 express 요청
express는 응답하는거임
----------------------------------------------------------------------------------------------------------------
json이란?:
	자바스크립트 오브젝트 노테이션

이세상에 유튜브 하는사람이 너무 많음 >> 그럴때마다 코드를 존나 많이 만드는건 말이 안댐 그래서 변수지정을 해줄거임
app.get('/user/:id', (req,res) => {
	res.json({'sound':"멍멍"})
})
여기서id가 파라미터 즉, 변수이다.


params와 query:
	params 는 변수로 라우팅지정가능
	query 는 ? 를 이용하여 터미널에 띄우기 가능, &사용

cors:
   html 이 들러오면 오류가 남 > npm cors모듈을 설치해야 함(이미 깔려있음)
	npm install cors 로 모듈을 다운받고 나서 app.use(cors())를 하면 모든 파일을 다 허용함
	근데 cors() 안에 파일을 넣으면 그 파일에서 오는건 다 컷해버리는 그런 모듈임!

 토큰값을 헤더에 담아서 보낸다. 그리고 미들웨어에서 처리를 해서 토큰이 유효한지 확인하고
유효하다면 다음 작업을 할 수 있게 하고 안되면 에러로 돌려보냄


jwt와 토큰:

1.쿠키인증:쿠키는 keyvalue형식의 문자열 덩어리이다. 
클라이언트가 어떠한 웹사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버를 통해
클라이언트의 브라우저에 설치되는 작은 기록 정보 파일이다.
각 사용자마다 브라우저에 정보를 저장하니 고유 정보 식별이 가능한것이다

>>브라우저(클라이언트)가 서버에 요청(접속)을 보낸다
>>서버느느 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은
정보를 응답 헤더의 set쿠키에 담는다
>>이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 쿠키에
담아 보낸다. 
>>서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별하거나 
정보를 바탕으로 추천 광고를 띄우거나 한다

쿠키의 단점: 보안에 취약하다 (요청시 쿠키의 값을 그래도 보내기때문에 유출 및조작 위험 큼)
또한 용량제한이 있어 많은 정보를 담을수 없으며 웹브라우저마다 쿠키에 대한 지원 형태가
다르기 때문에 브라우저간 공유가 불가능하다. 쿠키의 사이즈가 커질수록 네트워크에 부하가 걸림



2.세션인증:이러한 쿠키의 보안적 이슈 때문에, 세션은 비밀번호 등 클라이언트의 
민감한 인증 정보를 브라우저가 아닌 서버측에 저장하고 관리함
서버의 메모리에 저장하기도 하고 서버의 로컬 파일이나 데이터베이스에 저장하기도 한다.
핵심은 민감한 정보는 클라이언트에 보내지 않고 서버에서 모두 관리한다는 점이다

>>세션의 단점: 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하감


3.토큰인증:토큰 기반 인증시스템은 클라이언트가 서버에 접속을 하면 서버에서
해당 클라이언트에게 인증되었다는 의미로 토큰을 부여함 이 토큰을 유일하며 
토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서
보낸다. 그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 
일치 여부를 체크하여 인증 과정을 처리하게 된다
기존의 세션기반 인증은 서버가 파일이나 데이터베이스에 세션정보를 가지고 있어야 하고
이를 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생한다. 하지만 토큰은 세션과는
달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 
관리했던 서버의 부담을 덜 수 있다. 토큰 자체에 데이터가 들어있기 때문에 클라이언트에서
받아 위조되었는지 판별만 하면 되기 때문이다. 토큰은 앱과 서버가 통신 및 인증할때 
가장 많이 사용됨 왜냐하면 웹에는 쿠키와 세션이 있지만 앱에는 없기 때문임

>>사용자가 아이디와 비밀번호로 로그인을 한다
>>서버 측에서 사용자에게 유일한 토큰을 발급한다
>>클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고 서버에
요청을 할때마다 해당 토큰을 서버http요청 헤더에 포함시켜 전달한다
>>서버는 전달받은 토큰을 검증하고 요청에 응답한다 토큰에는 요청한 사람의 정보가
담겨있기에 서버는 db를 조회하지 않고 누가 요청했는지 알 수 있다

토큰의 단점:쿠키,세션과 다르게 토큰 자체의 데이터 길이가 길어서 인증 요청이
많아질수록 네트워크 부하가 심해질 수 있다 또한 Payload 자체는 암호화되지 않기 때문에
유저의 중요한 정보는 담을 수 없다. 마지막으로 토큰을 탈취당하면 대처하기 어렵다
(그래서 사용기간 제한을 설정하는 식으로 극복함)


jwt란 인증에 필요한 정보들을 암호화시킨 json토큰을 의미한다. 그리고 jwt토큰을 
http 헤더에 실어 서버가 클라이언트를 식별하는 방식이다. 

>>사용자가 로그인 인증을 요청한다.
>>서버에서 클라이언트로부터 인증요청을 받으면 Header, PayLoad, Signature를 정의한다
이들을 각각 Base64로 한번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게
발급한다.
>>클라이언트는 서버로부터 받은 jwt를 로컬 스토리지에 저장한다. (쿠키나 다른곳도 가능)
API를 서버에 요청할 때 header에 토큰을 담아서 보낸다
>>서버가 할 일은 클라이언트가 header에 담아서 보낸 jwt가 내서버에서 발행한 것인지
일치 여부를 확인하여 일치한다면 인증해주고 아니라면 통과시키지 않는다
>>클라이언트가 서버에 요청을 했는데 만일 엑세스 토큰의 시간이 만료되면 클라이언트는 
리프레시 토큰을 이용해서 서버로부터 새로운 엑세스 토큰을 발급받는다

jwt는 서명(인증)이 목적이다!!

access 토큰:클라이언트가 가지고 있는 실제로 유저의 정보가 담긴 토큰으로, 클라이언트에서 요청이 오면
서버에서 해당 토큰에 있는 정보를 화룡ㅇ하여 사용자 정보에 맞게 응답을 진행
refresh 토큰:재발급에 관여하는 토큰의 역할의 jwt이다